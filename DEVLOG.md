# 기능 구현 문서 (Feature Documentation)
해당 문서는 프로젝트 진행 중 구현한 기능들의 동작 흐름과 데이터 처리 구조를 정리한 개발 문서입니다.

---

## 결제하기 구조
프론트→ paymentKey, orderId, amount, user_id 등 결제정보를 API로 보내기
Superbase Edge Function → Supabase DB insert
전체 흐름: React → Edge Function → Supabase DB

```
[React]
useEffect → fetch(save-order)

       ↓

[Supabase Edge Function]
- user_id 파악 가능
- DB insert

       ↓

[Supabase DB]
OrdersHeaders 테이블에 저장
```

## Front => Edge Functions API => Supabase DB 데이터 전송 플로우 (2가지)
첫번째 (상품 상세페이지 1:1 데이터 전송)

```
- 1. 상품 구매 클릭 시 토스페이먼츠 API로 인자값 전달 (상품 정보는 객체에서 배열로 변환하여 전송)
- 2. 토스페이먼츠 API코드에서 결제페이지로 전달하는 인자값에 추가하는것이 아닌 세션스토리지에 JSON 문자열로 저장
- 3. 결제 성공 페이지에서 세션스토리지에 저장한 요소를 꺼내어 JSON 배열로 변환 후 변수에 할당 후 state에도 할당
- 4. 백엔드 서버로 fetch할 때 변수에 할당한 요소도 body의 인자값으로 전달 & 전달 후 더미데이터가 된 세션스토리지 요소는 제거
- 5. 프론트 에서 fetch한 데이터를 백엔드에서 받고 2개의 테이블에 각각 전송 (상품정보 테이블 & 구매내역 정보 테이블)
- 6. 백엔드 서버에서 배열로 담겨진 상품정보 변수에 map()을 사용하여 배열 안 각 객체에 key-value값을 할당 후 insert 
- (객체에게 key-value값을 지정 해주었으니 해당 key명과 일치하는 컬럼에 value값이 할당 됨)
- (1:1 상품은 어차피 객체여서 변환하지 않아도 되지만 백엔드에서 받을 데이터명과 데이터 구조를 통일  & 재사용성을 고려하여 둘 다 배열로 통일)
```

두번째 (장바구니 1:N  데이터 전송)

```
- 1. 상품 구매 클릭 시 토스페이먼츠 API로 인자값 전달 (상품 정보는 기존 cart변수에 담긴 배열에 map을 돌려 cart변수 안에 들어 있는 각각의 객체에게 key값과 value값을 지정해준 후 모든 객체를 하나의 배열로 감싸 인자값으로 전달)
- 2. 토스페이먼츠 API코드에서 결제페이지로 전달하는 인자값에 추가하는것이 아닌 세션스토리지에 JSON 문자열로 저장
- 3. 결제 성공 페이지에서 세션스토리지에 저장한 요소를 꺼내어 JSON 배열로 변환 후 변수에 할당 후 state에도 할당
- 4. 백엔드 서버로 fetch할 때 변수에 할당한 요소도 body의 인자값으로 전달 후 더미데이터가 된 세션스토리지 요소는 제거
- 5. 프론트 에서 fetch한 데이터를 백엔드에서 받고 2개의 테이블에 각각 전송 (상품정보 테이블 & 구매내역 정보 테이블)
- 6. 백엔드 서버에서 배열로 담겨진 상품정보 변수에 map()을 사용하여 배열 안 각 객체에 key-value값을 할당 후 insert 
- (객체에게 key-value값을 지정 해주었으니 해당 key명과 일치하는 컬럼에 value값이 할당 됨)
```

공통 개념 정리
(1:1 & 1:N을 둘다 배열 형태로 전송하는 이유는 데이터의 통일성 때문)
- 객체와 배열 어느 타입으로 전송 하던 상관없지만 데이터의 통일을 해두면 유지보수나 코드 작성에도 효율적임

(세션스토리지에 문자열로 저장하는 이유)
- 로컬스토리지 & 세션스토리지는 key-value를 문자열로만 보관 함

---

## 결제하기 금액 검증 로직 흐름
- 1. 장바구니 & 상품 상세페이지에서 구매 버튼을 클릭 하면 handleBuyNow() 함수를 실행하여 세션 검사와 API에 전달할 값들을 변수에 저장
- 2. 금액 조작 검증용 변수를 fetch(create-order)로 결제 시작 전에 API에 전달 후 DB에 임시 저장하여 
     클라이언트에서 값 변경하여도 최초 금액 저장되어 비교 가능
- 3. 성공 페이지 도착하면 다시 한번 세션 검사 후 파라미터로 전달 받은 쿼리스트링 값들을 변수에 할당 한 후 fetch(save-order)로 구매 정보 API로 전달 후 
     임시 저장된 진짜 금액과 토스페이먼츠가 반환한 값이 일치한지 검사 후 일치할 시 insert 및 UPDATE 일치하지 않을 시 에러를 프론트에게 전달
- 4. 프론트에서 서버로부터 반환 받은 값이 에러일 시 결제 실패 페이지로 이동 후 retrun을 반환하고 성공 시 콘솔에 성공 멘트 남기며 세션 스토리지에 저장된 더미 데이터 제거

(DB임시 저장 시 payment_status에 "PENDING"로 임시 저장 되며, 결제 확정 시 "PAID"로 UPDATE)
- create-order: 결제 시작 시 임시 구매 정보 저장(PENDING 상태), 
                최초 금액을 저장하여 금액 조작 여부를 판단하기 위한 정보 제공
- save-order: 1차·2차 금액 검증을 수행 후 통과하면 주문 정보 저장(Orders / OrdersHeaders)
              임시 상태를 PAID로 업데이트
[1차 금액 검증: DB vs 토스] = 데이터베이스에 임시로 저장한 값과 토스가 반환한 값을 검사
[2차 금액 검증: 클라이언트 vs 토스] = 쿼리스트링으로 반환된 값과 토스가 반환한 값을 검사

-  개선사항: 학습용으로는 기본적인 금액 검증 및 보안 로직을 갖추고 있으나, 실제 상용 서비스 기준에서는 보안 요소가 부족하므로 추후 보안 관련 로직을 더 보강할 필요가 있음

---


📌 개발 인사이트 (Developer Insights)
이번 결제 보안 로직을 구현하면서 다음과 같은 기술적 인사이트를 얻었다.
- API를 도입하는 이유와 프론트–서버–DB 간의 데이터 흐름을 실제 사례를 통해 이해함
- 데이터 변조 가능성, 금액 위·변조, 클라이언트 신뢰 불가 등 보안 로직이 필요한 근본적인 이유를 체감함
- 결제 흐름과 같이 복잡한 프로세스에서는 플로우 설계와 사전 기획 단계의 중요성이 크다는 것을 경험으로 깨달음

---